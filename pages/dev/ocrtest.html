<!doctype html>
<html>
  <body>
    <h2>OCR Receipt Test (Expense Parser + Smart Fallback)</h2>

    <p>
      1) Choose a RECEIPT or INVOICE PDF/JPG<br>
      2) Click "Scan Receipt"<br>
      3) See parsed output below
    </p>

    <input type="file" id="file" />
    <button id="btn">Scan Receipt</button>

    <p id="status" style="margin-top:10px; font-weight:bold; color:#333;">
      Status: Waiting for file…
    </p>

    <!-- Parsed summary -->
    <h3>Parsed Receipt Summary</h3>
    <table border="1" cellpadding="6" cellspacing="0">
      <tr><th>Vendor</th><td id="sum-vendor"></td></tr>
      <tr><th>Date</th><td id="sum-date"></td></tr>
      <tr><th>Total Amount</th><td id="sum-total"></td></tr>
      <tr><th>Tax Amount</th><td id="sum-tax"></td></tr>
      <tr><th>Currency</th><td id="sum-currency"></td></tr>
    </table>

    <h3>Raw Fields Map (from receipt parser)</h3>
    <pre id="fields" style="white-space:pre-wrap; border:1px solid #ccc; padding:10px; min-height:40px;"></pre>

    <h3>Plain Text</h3>
    <pre id="text" style="white-space:pre-wrap; border:1px solid #ccc; padding:10px; min-height:150px;"></pre>

    <script>
      const btn = document.getElementById("btn");
      const statusEl = document.getElementById("status");
      const fieldsEl = document.getElementById("fields");
      const textEl = document.getElementById("text");

      const vendorEl   = document.getElementById("sum-vendor");
      const dateEl     = document.getElementById("sum-date");
      const totalEl    = document.getElementById("sum-total");
      const taxEl      = document.getElementById("sum-tax");
      const currencyEl = document.getElementById("sum-currency");

      function parseLines(text) {
        return text
          .split(/\r?\n/)
          .map(l => l.trim())
          .filter(Boolean);
      }

      function pickVendor(fields, text) {
        // 1) Try structured fields first if Google ever returns them
        const f = fields || {};
        const structuredVendor =
          f["supplier_name"] ||
          f["merchant_name"] ||
          f["vendor_name"];
        if (structuredVendor) return structuredVendor;

        // 2) Fallback: first "nice" line of text, skipping obvious junk
        const lines = parseLines(text);
        const skipWords = [
          "invoice", "invoice n", "receipt", "paid on",
          "payment method", "amount due", "total",
          "thanks for your business", "thank you for your business",
          "customer's address", "customer address", "designation",
          "unit price", "quantity", "balance due"
        ];
        for (const line of lines) {
          const low = line.toLowerCase();
          if (skipWords.some(w => low.includes(w))) continue;
          if (/^\d/.test(line)) continue; // starts with number
          return line;
        }
        return "";
      }

      function pickDate(fields, text) {
        const f = fields || {};
        // 1) Structured date if present
        const structuredDate =
          (f["receipt_date"] || f["invoice_date"] || "").trim();
        if (structuredDate) return structuredDate;

        // 2) First date-looking string in text
        const lines = parseLines(text);
        const datePatterns = [
          /\b\d{4}-\d{2}-\d{2}\b/,        // 2025-12-03
          /\b\d{1,2}\/\d{1,2}\/\d{2,4}\b/ // 12/03/25 or 12/03/2025
        ];
        for (const line of lines) {
          for (const r of datePatterns) {
            const m = line.match(r);
            if (m) return m[0];
          }
        }
        return "";
      }

      function pickTotals(fields, text) {
        const f = fields || {};
        let total = f["total_amount"] || "";
        let tax   = f["tax_amount"]   || "";
        let currency = f["currency"] || f["currency_code"] || "";

        const lines = parseLines(text);
        const moneyRegex = /(\d+(?:[.,]\d{2})?)/;

        // Find all money-ish values with currency hints in text
        const moneyCandidates = [];
        for (let i = 0; i < lines.length; i++) {
          const l = lines[i];
          if (/[€$]|usd|eur|gbp/i.test(l)) {
            const m = l.match(moneyRegex);
            if (m) {
              const val = parseFloat(m[1].replace(",", "."));
              if (!isNaN(val)) {
                moneyCandidates.push({
                  value: val,
                  raw: m[1],
                  line: l.toLowerCase(),
                  idx: i
                });
              }
            }
          }
        }

        // Text-derived total: look near "Amount due" / "Total"
        let textTotal = null;
        for (let i = 0; i < lines.length; i++) {
          const l = lines[i].toLowerCase();
          if (
            l.includes("amount due") ||
            l.includes("balance due") ||
            l === "total" ||
            l.startsWith("total ")
          ) {
            const windowLines = [lines[i], lines[i + 1], lines[i + 2]];
            for (const wl of windowLines) {
              if (!wl) continue;
              if (!/[€$]|usd|eur|gbp/i.test(wl)) continue;
              const m = wl.match(moneyRegex);
              if (m) {
                const v = parseFloat(m[1].replace(",", "."));
                if (!isNaN(v)) {
                  textTotal = { num: v, raw: m[1] };
                  break;
                }
              }
            }
            if (textTotal) break;
          }
        }

        // Decide on total:
        // 1) Try structured total if it's not suspiciously tiny
        let chosenTotal = "";
        if (total) {
          const parsed = parseFloat(total.replace(",", "."));
          const maxCandidate = moneyCandidates.reduce(
            (max, c) => (c.value > max ? c.value : max),
            0
          );
          // if parsed total is non-zero and not way smaller than obvious amounts, use it
          if (!isNaN(parsed) && parsed > 0 && parsed >= maxCandidate * 0.5) {
            chosenTotal = total;
          }
        }
        // 2) Otherwise use text-derived total
        if (!chosenTotal && textTotal) {
          chosenTotal = textTotal.raw;
        }

        // TAX: structured if present, otherwise look for "tax"/"vat" with money
        let chosenTax = tax;
        if (!chosenTax) {
          for (const line of lines) {
            if (!/tax|vat/i.test(line)) continue;
            if (!/[€$]|usd|eur|gbp/i.test(line)) continue;
            const m = line.match(moneyRegex);
            if (m) {
              chosenTax = m[1];
              break;
            }
          }
        }

        // Currency from structured first, else from text
        if (!currency) {
          for (const c of moneyCandidates) {
            if (/usd|\$/i.test(c.line)) { currency = "USD"; break; }
            if (/eur|€ /i.test(c.line)) { currency = "EUR"; break; }
            if (/gbp|£/i.test(c.line)) { currency = "GBP"; break; }
          }
        }

        return { total: chosenTotal, tax: chosenTax, currency };
      }

      btn.addEventListener("click", async () => {
        const input = document.getElementById("file");
        const file = input.files[0];

        if (!file) {
          statusEl.textContent = "Status: Pick a file first.";
          return;
        }

        statusEl.textContent = "Status: Reading file…";
        fieldsEl.textContent = "";
        textEl.textContent   = "";
        vendorEl.textContent = dateEl.textContent =
          totalEl.textContent = taxEl.textContent = currencyEl.textContent = "";

        const reader = new FileReader();
        reader.onload = async () => {
          try {
            const base64 = reader.result.split(",")[1];

            statusEl.textContent = "Status: Sending to OCR (receipt mode)…";

            const res = await fetch(
              "https://fv-ocr-300398089669.us-central1.run.app/fvOcr",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  mode: "receipt",
                  content: base64,
                  mimeType: file.type || "application/pdf"
                })
              }
            );

            const json = await res.json();
            statusEl.textContent = json.ok ? "Status: OK" : "Status: ERROR";

            // show fields map from backend
            fieldsEl.textContent = JSON.stringify(json.fields || {}, null, 2);

            const docText = json.document?.text || "(no text returned)";
            textEl.textContent = docText;

            const fields = json.fields || {};

            const vendor = pickVendor(fields, docText);
            const date = pickDate(fields, docText);
            const totals = pickTotals(fields, docText);

            vendorEl.textContent   = vendor   || "(not found)";
            dateEl.textContent     = date     || "(not found)";
            totalEl.textContent    = totals.total    || "(not found)";
            taxEl.textContent      = totals.tax      || "(not found)";
            currencyEl.textContent = totals.currency || "(not found)";
          } catch (err) {
            statusEl.textContent = "Status: ERROR – see console";
            console.error(err);
          }
        };

        reader.readAsDataURL(file);
      });
    </script>
  </body>
</html>
