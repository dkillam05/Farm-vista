<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FarmVista • Add Field to Trial</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#3B7E46" />

  <script src="/Farm-vista/js/theme-boot.js"></script>

  <!-- ABSOLUTE PATHS -->
  <link rel="manifest" href="/Farm-vista/manifest.webmanifest" />
  <link rel="apple-touch-icon" href="/Farm-vista/assets/icons/apple-touch-icon.png" />
  <link rel="icon" href="/Farm-vista/assets/icons/icon-192.png" />
  <link rel="stylesheet" href="/Farm-vista/assets/css/theme.css" />
  <link rel="stylesheet" href="/Farm-vista/assets/css/app.css" />
  <!-- Swipe styles for shared helper -->
  <link rel="stylesheet" href="/Farm-vista/assets/css/swipe-list.css" />

  <!-- FVData helpers -->
  <script src="/Farm-vista/js/fv-data.js"></script>

  <style>
    :root{
      --card-max: 900px;
      --page-bottom-gap: 72px;
      --accent: #2F6C3C;
      --combo-gap:4px;
      --combo-radius:12px;
      --combo-btn-radius:10px;
      --combo-shadow:0 12px 26px rgba(0,0,0,.18);
      --combo-item-pad:10px 8px;
      --combo-max-h:50vh;
    }

    html{-webkit-text-size-adjust:100%}
    body{
      background: var(--app-bg,var(--surface));
      overflow-x:hidden;
    }

    .wrap{
      max-width: var(--card-max);
      margin: 0 auto;
      padding: clamp(14px,3vw,22px);
      padding-bottom: calc(env(safe-area-inset-bottom,0px) + var(--ftr-h,42px) + var(--page-bottom-gap)) !important;
      box-sizing:border-box;
      display:grid;
      gap:16px;
    }

    .hero{
      border:1px solid var(--border);
      border-radius:18px;
      background:var(--surface);
      box-shadow:var(--shadow,0 12px 28px rgba(0,0,0,.12));
      overflow:visible;
    }

    .hero-head{
      display:flex;
      justify-content:flex-start;
      align-items:flex-start;
      gap:12px;
      padding:14px 16px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(90deg, rgba(47,108,60,.12), transparent);
    }

    .hero-head-main{
      display:flex;
      align-items:flex-start;
      gap:12px;
    }

    .hero-head .icon{
      width:24px;
      height:24px;
      color:var(--accent);
      display:grid;
      place-items:center;
      margin-top:2px;
    }

    .hero-head h1{
      margin:0;
      font-size:clamp(20px,3.2vw,26px);
      line-height:1.2;
    }

    .muted{ color:var(--muted,#67706B); }

    .body{
      padding:16px;
      display:grid;
      gap:14px;
    }

    .top-row{
      display:flex;
      flex-wrap:wrap;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px 16px;
    }

    .trial-summary{
      display:grid;
      gap:4px;
      font-size:0.9rem;
    }

    .trial-summary-title{
      font-weight:800;
      font-size:1rem;
    }

    .trial-summary-line{
      font-size:0.85rem;
      color:var(--muted,#67706B);
    }

    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:140px;
      padding:11px 16px;
      border-radius:12px;
      border:1px solid var(--border);
      background:var(--card-surface,var(--surface));
      font-weight:800;
      font-size:0.95rem;
      text-decoration:none;
      cursor:pointer;
      user-select:none;
      color:var(--text)!important;
      gap:6px;
    }
    .btn-primary{
      border-color:transparent;
      background:#2F6C3C;
      color:#fff!important;
    }
    .btn-quiet{
      min-width:auto;
      padding-inline:10px;
    }
    .btn[disabled]{
      opacity:.6;
      cursor:not-allowed;
    }

    .btn-small{
      padding:4px 8px;
      min-width:auto;
      font-size:0.8rem;
      border-radius:999px;
    }

    .btn-danger{
      border-color:#b3261e;
      color:#b3261e!important;
      background:rgba(179,38,30,.06);
    }

    .row{
      display:grid;
      gap:10px;
      grid-template-columns:1fr 1fr;
    }
    @media (max-width:800px){
      .row{ grid-template-columns:1fr; }
    }

    .field{
      position:relative;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .field label{
      display:block;
      font-weight:800;
      margin:0 0 2px;
    }
    .field small{
      font-size:0.8rem;
      color:var(--muted,#67706B);
    }

    .input,
    .textarea{
      width:100%;
      font:inherit;
      font-size:16px;
      color:var(--text);
      background:var(--card-surface,var(--surface));
      border:1px solid var(--border);
      border-radius:10px;
      padding:12px;
      outline:none;
    }
    .textarea{
      min-height:110px;
      resize:vertical;
    }

    .helper{
      font-size:0.8rem;
      color:var(--muted,#67706B);
      margin-top:2px;
    }

    .error-box{
      border:1px solid #b3261e;
      background:#fff;
      color:#b3261e;
      border-radius:10px;
      padding:10px 12px;
      display:none;
    }
    .error-box.show{
      display:block;
    }

    .input-error{
      border-color:#b3261e !important;
      box-shadow:0 0 0 1px rgba(179,38,30,.3);
      background:rgba(179,38,30,.03);
    }

    .ta-wrap{
      position:relative;
    }
    .textarea.with-mic{
      padding-right:52px;
    }
    .mic-btn{
      position:absolute;
      right:10px;
      bottom:10px;
      width:36px;
      height:36px;
      border-radius:10px;
      border:1px solid var(--border);
      background:var(--surface);
      display:grid;
      place-items:center;
      cursor:pointer;
      color:var(--muted,#67706B);
    }
    .mic-btn[disabled]{
      opacity:.6;
      cursor:not-allowed;
    }
    .mic-btn.mic-active{
      background:#2F6C3C;
      color:#fff;
      border-color:#2F6C3C;
    }
    .mic-svg{
      width:18px;
      height:18px;
      display:block;
    }

    .no-spin::-webkit-outer-spin-button,
    .no-spin::-webkit-inner-spin-button{
      -webkit-appearance:none;
      margin:0;
    }
    .no-spin{
      -moz-appearance:textfield;
    }

    .combo{ position:relative; }
    .buttonish{
      width:100%;
      font:inherit;
      font-size:16px;
      color:var(--text);
      background:var(--card-surface,var(--surface));
      border:1px solid var(--border);
      border-radius:var(--combo-btn-radius);
      padding:12px;
      padding-right:42px;
      outline:none;
      text-align:left;
      cursor:pointer;
      position:relative;
    }
    .buttonish.has-caret::after{
      content:"";
      position:absolute;
      right:14px;
      top:50%;
      width:0;
      height:0;
      border-left:6px solid transparent;
      border-right:6px solid transparent;
      border-top:7px solid var(--muted,#67706B);
      transform:translateY(-50%);
      pointer-events:none;
    }
    .combo .combo-anchor{
      position:relative;
      display:inline-block;
      width:100%;
    }
    .combo-panel{
      position:absolute;
      left:0; right:0;
      top:calc(100% + var(--combo-gap));
      background:var(--surface);
      border:1px solid var(--border);
      border-radius:var(--combo-radius);
      box-shadow:var(--combo-shadow);
      padding:8px;
      display:none;
      z-index:9999; /* ensure dropdown is above cards */
    }
    .combo-panel.show{
      display:block;
    }
    .combo-panel .search{
      padding:4px 2px 8px;
    }
    .combo-panel .search input{
      width:100%;
      padding:10px;
      border:1px solid var(--border);
      border-radius:var(--combo-btn-radius);
      background:var(--card-surface,var(--surface));
      color:var(--text);
    }
    .combo-panel .list{
      max-height:var(--combo-max-h);
      overflow:auto;
      border-top:1px solid var(--border);
    }
    .combo-item{
      padding:var(--combo-item-pad);
      border-bottom:1px solid var(--border);
      cursor:pointer;
    }
    .combo-item:hover{
      background:rgba(0,0,0,.04);
    }
    .combo-item:last-child{
      border-bottom:none;
    }
    .combo-empty{
      padding:var(--combo-item-pad);
      color:#67706B;
    }

    .fields-hero{
      border:1px solid var(--border);
      border-radius:18px;
      background:var(--surface);
      box-shadow:var(--shadow,0 10px 22px rgba(0,0,0,.08));
      overflow:hidden;
    }

    .fields-head{
      padding:12px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .fields-head h2{
      margin:0;
      font-size:1rem;
    }
    .fields-body{
      padding:14px 16px 8px;
      display:grid;
      gap:12px;
    }

    .field-list-label{
      font-size:0.78rem;
      text-transform:uppercase;
      letter-spacing:0.08em;
      color:var(--muted,#67706B);
      margin-bottom:4px;
    }

    .field-list-empty{
      font-size:0.9rem;
      color:var(--muted,#67706B);
    }

    .field-card{
      border-radius:12px;
      border:1px solid var(--border);
      background:var(--card-surface,var(--surface));
      padding:9px 10px;
      display:grid;
      gap:4px;
      font-size:0.9rem;
      position:relative;
    }
    .field-card-top{
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:flex-start;
    }
    .field-card-title{
      font-weight:700;
    }
    .field-card-sub{
      font-size:0.82rem;
      color:var(--muted,#67706B);
    }
    .field-card-note{
      font-size:0.85rem;
      color:var(--muted,#67706B);
    }

    .field-card-actions{
      display:flex;
      gap:6px;
    }

    @media (max-width: 720px){
      .field-card-actions{
        display:none;
      }
    }

    .fields-actions{
      margin-top:4px;
      display:flex;
      justify-content:flex-end;
      gap:10px;
      padding:0 16px 14px;
    }

    .fields-swipe-hint{
      font-size:0.78rem;
      color:var(--muted,#67706B);
      margin-top:4px;
    }

    .overlap-hero{
      border:1px solid var(--border);
      border-radius:18px;
      background:var(--surface);
      box-shadow:var(--shadow,0 8px 18px rgba(0,0,0,.06));
      overflow:hidden;
    }
    .overlap-head{
      padding:10px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .overlap-head h2{
      margin:0;
      font-size:0.96rem;
    }
    .overlap-badge{
      font-size:0.78rem;
      text-transform:uppercase;
      letter-spacing:0.08em;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #b3261e;
      color:#b3261e;
      background:rgba(179,38,30,.06);
      white-space:nowrap;
    }
    .overlap-body{
      padding:12px 16px 12px;
      display:grid;
      gap:8px;
    }
    .overlap-summary{
      font-size:0.82rem;
      color:var(--muted,#67706B);
    }
    .overlap-row{
      border-radius:10px;
      border:1px solid var(--border);
      padding:8px 10px;
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:flex-start;
      font-size:0.86rem;
    }
    .overlap-row-main{
      display:grid;
      gap:2px;
    }
    .overlap-row-title{
      font-weight:700;
    }
    .overlap-row-sub{
      font-size:0.8rem;
      color:var(--muted,#67706B);
    }
    .overlap-row-meta{
      font-size:0.8rem;
      color:var(--muted,#67706B);
      white-space:nowrap;
      padding-top:2px;
    }

    .toast{
      position:fixed;
      left:50%;
      bottom:calc(env(safe-area-inset-bottom,0px) + 72px);
      transform:translateX(-50%);
      background:#2F6C3C;
      color:#fff;
      padding:10px 14px;
      border-radius:10px;
      box-shadow:0 6px 20px rgba(0,0,0,.25);
      z-index:99999;
      display:none;
      white-space:nowrap;
      max-width:92vw;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.show{
      display:block;
      animation:fadeout 3.2s forwards;
    }
    @keyframes fadeout{
      0%{opacity:1}
      85%{opacity:1}
      100%{opacity:0}
    }

    .modal-backdrop{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      backdrop-filter:blur(2px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:200000;
    }
    .modal-backdrop.show{
      display:flex;
    }
    .modal-sheet{
      background:var(--surface);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow:0 20px 40px rgba(0,0,0,.35);
      max-width:90%;
      width:380px;
      padding:20px 22px;
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .modal-title{
      font-size:1rem;
      font-weight:700;
      color:var(--text);
    }
    .modal-body{
      font-size:0.9rem;
      color:var(--muted,#67706B);
    }
    .modal-actions{
      margin-top:6px;
      display:flex;
      justify-content:flex-end;
      gap:10px;
    }
    .modal-btn{
      padding:8px 16px;
      border-radius:10px;
      font-size:0.9rem;
      font-weight:700;
      cursor:pointer;
      border:1px solid var(--border);
      background:var(--surface-strong,var(--surface));
      color:var(--text);
    }
    .modal-btn:hover{
      background:color-mix(in srgb, var(--surface) 70%, var(--border) 30%);
    }
    .modal-btn-primary{
      background:var(--accent);
      border-color:var(--accent);
      color:#fff;
    }

    /* MH trials: dim the Add Field form when locked */
    #addFieldForm.is-locked{
      opacity:0.45;
    }
  </style>

  <script>
    (function(){
      if(!customElements.get('fv-shell')){
        const s=document.createElement('script');
        s.src='/Farm-vista/js/fv-shell.js';
        s.defer=true;
        document.head.appendChild(s);
      }
    })();
  </script>

  <script type="module">
    import {
      ready,
      getFirestore, getAuth,
      collection, getDocs, getDoc, doc, deleteDoc, onSnapshot, addDoc
    } from '/Farm-vista/js/firebase-init.js';

    import { NAV_MENU } from '/Farm-vista/js/menu.js';
    import { initSwipeList } from '/Farm-vista/js/fv-swipe-list.js';

    const CONFIG = {
      COLLECTION_TRIALS: 'fieldTrials',
      COLLECTION_FARMS:  'farms',
      COLLECTION_FIELDS: 'fields',
      RETURN_URL: '/Farm-vista/pages/crop-production/trials/trials-edit.html',
      YIELD_URL: '/Farm-vista/pages/crop-production/trials/trial-field-yield.html',
      YIELD_URL_MH: '/Farm-vista/pages/crop-production/trials/trial-field-yield-mh.html'
    };

    const STATE = {
      db: null,
      auth: null,
      user: null,
      fvUser: null,
      orgId: null,
      trialId: null,
      trial: null,
      farms: [],

      fields: [],
      selectedFarm: null,
      selectedField: null,
      selectedFieldMaxAcres: null,
      existingFields: [],
      pendingFields: [],
      overlaps: []
    };

    const $  = (sel, root=document) => root.querySelector(sel);

    let toastEl, errorBox, debugLogEl;

    let farmCombo, fieldCombo;
    let fieldFarmBtn, fieldFarmPanel, fieldFarmList, fieldFarmSearch;
    let fieldFieldBtn, fieldFieldPanel, fieldFieldList, fieldFieldSearch;
    let trialNameMain, trialCropMain, trialTypeLine, trialTreatmentLine;
    let trialAcresInput, trialAcresHelp, notesInput, micBtn;
    let existingListEl, pendingListEl;
    let overlapHeroEl, overlapListEl, overlapSummaryEl, overlapBadgeEl;

    let addFieldFormEl, btnAddFieldEl, btnSaveFieldsEl;

    let lastNavTime = 0;
    let overlapCheckTimer = null;
    let trialFieldsUnsub = null;

    function diag(label, payload){
      const ts = new Date();
      const time = ts.toISOString().split('T')[1].replace('Z','');
      let line = time + '  ' + label;
      if(typeof payload !== 'undefined'){
        try{
          line += '  ' + JSON.stringify(payload, null, 2);
        }catch{
          line += '  ' + String(payload);
        }
      }
      console.log('[AddFieldToTrial]', label, payload ?? '');
      if(!debugLogEl) debugLogEl = document.getElementById('debugLog');
      if(debugLogEl){
        debugLogEl.textContent += line + '\n\n';
      }
    }

    async function waitForAuthReady() {
      const auth = getAuth();
      let tries = 40;
      return await new Promise(resolve => {
        const int = setInterval(() => {
          if (auth.currentUser) {
            clearInterval(int);
            resolve(auth.currentUser);
          }
          if (--tries <= 0) {
            clearInterval(int);
            resolve(null);
          }
        }, 100);
      });
    }

    async function waitForFVUser() {
      let tries = 40;
      return await new Promise(resolve => {
        const int = setInterval(() => {
          try{
            const fv = window.FVUserContext?.get?.();
            if(fv && fv.email){
              clearInterval(int);
              resolve(fv);
            }
          }catch{}
          if(--tries <= 0){
            clearInterval(int);
            resolve(null);
          }
        },100);
      });
    }

    function showToast(msg="Saved.", ms=3200){
      if(!toastEl) return;
      toastEl.textContent = msg;
      toastEl.classList.remove('show');
      void toastEl.offsetWidth;
      toastEl.classList.add('show');
      setTimeout(()=>toastEl.classList.remove('show'), ms);
    }

    function showError(msg){
      if(!errorBox) errorBox = document.getElementById('errBox');
      if(!errorBox) return;
      if(msg){
        errorBox.textContent = msg;
        errorBox.classList.add('show');
      }else{
        errorBox.textContent = '';
        errorBox.classList.remove('show');
      }
    }

    function getQueryParam(name){
      const params = new URLSearchParams(window.location.search);
      return params.get(name) || null;
    }

    function inferName(data){
      return data.name || data.farmName || data.fieldName || data.label || "Unnamed";
    }

    /* --- mic dictation, copied pattern from maintenance-add --- */
    function wireMic(buttonId, textareaId){
      const btn = document.getElementById(buttonId);
      const ta  = document.getElementById(textareaId);
      if(!btn || !ta) return;

      const ok = ('webkitSpeechRecognition' in window) || ('SpeechRecognition' in window);
      if(!ok){
        btn.style.display = "none";
        return;
      }

      const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;
      const rec = new Rec();
      rec.lang = "en-US";
      rec.interimResults = true;
      rec.continuous = false;

      let active = false;
      let baseText = "";

      const setMic = on=>{
        btn.classList.toggle("mic-active", on);
        btn.setAttribute("aria-label", on ? "Stop dictation" : "Start dictation");
      };

      btn.addEventListener("click", ()=>{
        if(!active){
          baseText = ta.value ? (ta.value + " ") : "";
          try{ rec.start(); active=true; setMic(true); }catch{}
        }else{
          try{ rec.stop(); rec.abort(); }catch{}
          active=false; setMic(false);
        }
      });

      rec.onresult = ev=>{
        let txt = "";
        for(let i=ev.resultIndex;i<ev.results.length;i++){
          txt += ev.results[i][0].transcript;
        }
        ta.value = baseText + txt;
      };
      rec.onend = ()=>{ active=false; setMic(false); };
      rec.onerror = ()=>{ active=false; setMic(false); };
    }

    function setupMic(){
      const notes = document.getElementById("notes");
      if(notes){
        notes.classList.add("with-mic");
      }
      wireMic("notesMic", "notes");
    }

    function closeAllCombos(exceptPanel=null){
      document.querySelectorAll('.combo-panel.show').forEach(p=>{
        if(p!==exceptPanel) p.classList.remove('show');
      });
    }

    document.addEventListener('click', ()=> closeAllCombos());
    document.addEventListener('keydown', e=>{
      if(e.key==='Escape') closeAllCombos();
    });

    function makeCombo({btn,panel,list,searchInput=null,items=[],searchable=false,formatter=x=>String(x.label||x.name||x),onPick}){
      if(!btn||!panel||!list) return;
      panel.addEventListener('click',e=>e.stopPropagation());
      panel.addEventListener('mousedown',e=>e.stopPropagation());
      let DATA = items||[];
      function render(q=''){
        const qq=(q||'').toLowerCase();
        const rows=(DATA||[]).filter(x=>{
          const label=formatter(x).toLowerCase();
          return !qq || label.includes(qq);
        });
        let html='';
        if(rows.length){
          html=rows.map(x=>`<div class="combo-item" data-id="${String(x.id)}">${formatter(x)}</div>`).join('');
        }else{
          html=`<div class="combo-empty">(no matches)</div>`;
        }
        list.innerHTML=html;
      }
      function open(){
        closeAllCombos(panel);
        panel.classList.add('show');
        render('');
        if(searchable && searchInput){
          searchInput.value=''; searchInput.focus();
        }
      }
      function close(){ panel.classList.remove('show'); }
      btn.addEventListener('click',e=>{
        e.stopPropagation();
        panel.classList.contains('show')?close():open();
      });
      list.addEventListener('mousedown',e=>{
        const row=e.target.closest('.combo-item'); if(!row) return;
        const id=row.dataset.id;
        const it=(DATA||[]).find(x=>String(x.id)===id);
        if(!it) return;
        onPick?.(it); close();
      });
      if(searchable && searchInput){
        searchInput.addEventListener('input',e=>render(e.target.value));
      }
      return { setItems(arr){ DATA=Array.isArray(arr)?arr:[]; render(''); } };
    }

    function sortFieldRows(arr){
      if(!Array.isArray(arr)) return;
      arr.sort((a,b)=>{
        const aName = `${(a.farm && a.farm.name) || ''} • ${(a.field && a.field.fieldName) || ''}`.toLowerCase();
        const bName = `${(b.farm && b.farm.name) || ''} • ${(b.field && b.field.fieldName) || ''}`.toLowerCase();
        return aName.localeCompare(bName);
      });
    }

    async function loadTrial(){
      if(!STATE.trialId) return;
      try{
        diag('loadTrial.start', { trialId: STATE.trialId });
        const refDoc = doc(STATE.db, CONFIG.COLLECTION_TRIALS, STATE.trialId);
        const snap = await getDoc(refDoc);
        if(!snap.exists()){
          showError("This trial could not be found. It may have been deleted.");
          diag('loadTrial.missing', {});
          return;
        }
        STATE.trial = snap.data()||{};
        const t=STATE.trial;

        if(!STATE.orgId && t.orgId){
          STATE.orgId = t.orgId;
          diag('loadTrial.orgIdFromTrial', { orgId: STATE.orgId });
        }

        if(trialNameMain) trialNameMain.textContent = t.trialName || "Field Trial";
        if(trialCropMain){
          const bits=[];
          if(t.cropYear!=null) bits.push(t.cropYear);
          if(t.crop) bits.push(t.crop);
          trialCropMain.textContent = bits.join(" • ") || "—";
        }
        if(trialTypeLine){
          const parts=[];
          if(t.trialType) parts.push(`Type: ${t.trialType}`);
          if(t.operationTask) parts.push(`Operation: ${t.operationTask}`);
          trialTypeLine.textContent = parts.join("  |  ") || "";
        }
        if(trialTreatmentLine){
          const parts=[];
          if(t.treatmentProduct) parts.push(`Treatment: ${t.treatmentProduct}`);
          if(t.check) parts.push(`Check: ${t.check}`);
          trialTreatmentLine.textContent = parts.join("  |  ") || "";
        }
        diag('loadTrial.success', { trialName: t.trialName || null });
      }catch(err){
        console.error("Error loading trial:",err);
        diag('loadTrial.error', { code: err.code, message: err.message });
        showError("Unable to load trial details. You can still add a field, but some labels may be missing.");
      }
    }

    // Use Firestore fields trialType + seedTrialType to detect multi-hybrid
    function isMultiHybridTrial(){
      const t = STATE.trial || {};
      const type = (t.trialType || '').toLowerCase();
      const seed = (t.seedTrialType || '').toLowerCase();

      const isSeedVarieties  = type === 'seed varieties';
      const isMultiHybrid    = seed === 'multiple hybrid trial';

      return isSeedVarieties && isMultiHybrid;
    }

    async function loadFarmsAndFields(){
      const db=STATE.db;
      try{
        const farmSnap = await getDocs(collection(db, CONFIG.COLLECTION_FARMS));
        const farms=[];
        farmSnap.forEach(d=>{
          const data=d.data()||{};
          const name=inferName(data);
          if(name) farms.push({id:d.id,name:String(name)});
        });
        farms.sort((a,b)=>a.name.localeCompare(b.name));
        STATE.farms=farms;
        diag('loadFarms.ok', { count: farms.length });
      }catch(err){
        console.error("Error loading farms:",err);
        diag('loadFarms.error', { code: err.code, message: err.message });
        STATE.farms=[];
      }
      try{
        const fieldSnap = await getDocs(collection(db, CONFIG.COLLECTION_FIELDS));
        const fields=[];
        fieldSnap.forEach(d=>{
          const data=d.data()||{};
          const fieldName=inferName(data);
          if(!fieldName) return;
          const farmId=data.farmId||data.farmDocId||data.farm||null;
          const farmName=data.farmName||data.farm||"";
          const tillable=data.tillable ?? data.tillableAcres ?? data.acres ?? null;
          fields.push({
            id:d.id,
            fieldName:String(fieldName),
            farmId,
            farmName: farmName ? String(farmName) : null,
            tillable: tillable!=null ? Number(tillable) : null
          });
        });
        STATE.fields=fields;
        diag('loadFields.ok', { count: fields.length });
      }catch(err){
        console.error("Error loading fields:",err);
        diag('loadFields.error', { code: err.code, message: err.message });
        STATE.fields=[];
      }
    }

    function attachTrialFieldsListener(){
      if(!STATE.db || !STATE.trialId) return;
      if(trialFieldsUnsub) return;

      const path = `${CONFIG.COLLECTION_TRIALS}/${STATE.trialId}/fields`;
      const ref = collection(STATE.db, path);

      diag('trialFields.listener.attach', { path });

      trialFieldsUnsub = onSnapshot(ref, (snap)=>{
        const rows=[];
        snap.forEach(d=>{
          const data = d.data() || {};
          const farm = {
            id:   data.farmId || null,
            name: data.farmName || 'Unknown farm'
          };
          const field = {
            id:        data.fieldId || null,
            fieldName: data.fieldName || 'Unknown field',
            tillable:  data.tillable != null ? Number(data.tillable) : null
          };
          const acres = data.trialAcres != null ? Number(data.trialAcres) : null;
          rows.push({
            docId: d.id,
            farm,
            field,
            acres,
            notes: data.notes || ''
          });
        });
        sortFieldRows(rows);
        STATE.existingFields = rows;
        diag('trialFields.listener.snap', { count: rows.length });
        renderFieldLists();
      }, (err)=>{
        console.error('Error listening trial fields:', err);
        diag('trialFields.listener.error', { code: err.code, message: err.message });
      });
    }

    function detachTrialFieldsListener(){
      if(trialFieldsUnsub){
        try{ trialFieldsUnsub(); }catch{}
        trialFieldsUnsub = null;
        diag('trialFields.listener.detached', {});
      }
    }

    function resume(){
      if(!STATE.db || !STATE.trialId) return;
      if(!trialFieldsUnsub){
        attachTrialFieldsListener();
      }
    }

    function refreshFarmCombo(){
      if(!farmCombo) return;
      const items=STATE.farms.map(f=>({id:f.id,label:f.name}));
      farmCombo.setItems(items);
    }

    function refreshFieldComboForFarm(farmId){
      STATE.selectedFarm = STATE.farms.find(f=>f.id===farmId) || null;
      STATE.selectedField = null;
      STATE.selectedFieldMaxAcres = null;
      if(fieldFarmBtn) fieldFarmBtn.textContent = STATE.selectedFarm ? STATE.selectedFarm.name : "— Select farm —";
      if(fieldFieldBtn) fieldFieldBtn.textContent = "— Select field —";
      if(trialAcresHelp) trialAcresHelp.textContent = "";
      if(!fieldCombo) return;
      const items = STATE.fields
        .filter(f=>!farmId || f.farmId===farmId)
        .map(f=>({
          id:f.id,
          label:f.farmName ? `${f.farmName} • ${f.fieldName}` : f.fieldName,
          raw:f
        }))
        .sort((a,b)=>a.label.localeCompare(b.label));
      fieldCombo.setItems(items);
    }

    function removePendingField(idx){
      const row = STATE.pendingFields[idx];
      if(!row) return;
      STATE.pendingFields.splice(idx,1);
      renderFieldLists();
      showToast("Field removed.");
    }

    async function removeExistingField(idx){
      const row = STATE.existingFields[idx];
      if(!row) return;
      const ok = window.confirm("Remove this field from the trial? This doesn't delete the field itself.");
      if(!ok) return;

      try{
        diag('removeExistingField.start', {
          trialId: STATE.trialId,
          docId: row.docId
        });
        await deleteDoc(doc(STATE.db, CONFIG.COLLECTION_TRIALS, STATE.trialId, 'fields', row.docId));
        // Snapshot listener will update STATE.existingFields and re-render
        showToast("Field removed from this trial.");
        diag('removeExistingField.success', {});
      }catch(err){
        console.error("Error removing field:", err);
        diag('removeExistingField.error', { code: err.code, message: err.message });
        showError("Error removing field from trial: " + (err && (err.message || err.code) || "Unknown error"));
      }
    }

    function openYieldForExisting(idx){
      const row = STATE.existingFields[idx];
      if(!row) return;
      const trialId = STATE.trialId || '';
      const fieldDocId = row.docId || '';

      const multiHybrid = isMultiHybridTrial();
      const base = multiHybrid ? CONFIG.YIELD_URL_MH : CONFIG.YIELD_URL;

      const url = `${base}?trialId=${encodeURIComponent(trialId)}&fieldDocId=${encodeURIComponent(fieldDocId)}`;
      window.location.href = url;
    }

    function openYieldForPending(){
      showToast("Save fields first, then come back to add yield.");
    }

    function isTouchPointer(){
      return (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
    }

    function applySwipeToLists(){
      try{
        if(!isTouchPointer()){
          diag('applySwipeToLists.skip', { reason: 'non-touch pointer; buttons only' });
          return;
        }

        if(existingListEl){
          initSwipeList(existingListEl, {
            itemSelector: '.fv-swipe-item[data-kind="existing"]',
            leftAction: {
              label: 'Add Yield',
              onAction: (itemEl) => {
                const idx = Number(itemEl.dataset.index);
                if(!Number.isNaN(idx)) openYieldForExisting(idx);
              }
            },
            rightAction: {
              label: 'Remove',
              onAction: (itemEl) => {
                const idx = Number(itemEl.dataset.index);
                if(!Number.isNaN(idx)) removeExistingField(idx);
              }
            }
          });
        }

        if(pendingListEl){
          initSwipeList(pendingListEl, {
            itemSelector: '.fv-swipe-item[data-kind="pending"]',
            leftAction: {
              label: 'Add Yield',
              onAction: () => {
                openYieldForPending();
              }
            },
            rightAction: {
              label: 'Remove',
              onAction: (itemEl) => {
                const idx = Number(itemEl.dataset.index);
                if(!Number.isNaN(idx)) removePendingField(idx);
              }
            }
          });
        }
      }catch(err){
        diag('applySwipeToLists.error', { message: err.message, stack: err.stack });
      }
    }

    function renderOverlapConflicts(rows){
      if(!overlapHeroEl || !overlapListEl || !overlapSummaryEl || !overlapBadgeEl) return;

      if(!rows || !rows.length){
        overlapHeroEl.style.display = 'none';
        overlapListEl.innerHTML = '';
        overlapSummaryEl.textContent = '';
        overlapBadgeEl.textContent = '';
        STATE.overlaps = [];
        return;
      }

      STATE.overlaps = rows;
      overlapHeroEl.style.display = 'block';

      overlapBadgeEl.textContent = `${rows.length} overlap${rows.length === 1 ? '' : 's'}`;
      overlapSummaryEl.textContent =
        "These fields are also used in other trials with the same crop year. Make sure strips don't overlap or it can ruin the test.";

      const html = rows.map(r => `
        <div class="overlap-row">
          <div class="overlap-row-main">
            <div class="overlap-row-title">${r.farmName} • ${r.fieldName}</div>
            <div class="overlap-row-sub">
              Trial: <strong>${r.trialName}</strong> (${r.statusLabel})
              ${r.operation ? ' • ' + r.operation : ''}
            </div>
          </div>
          <div class="overlap-row-meta">
            ${r.cropYear ?? ''}
          </div>
        </div>
      `).join('');

      overlapListEl.innerHTML = html;
    }

    async function checkOverlappingTrials(){
      try{
        if(!STATE.db || !STATE.trial || STATE.trial.cropYear == null){
          diag('overlap.skip', { reason: 'no trial or cropYear' });
          renderOverlapConflicts([]);
          return;
        }

        const fieldIds = new Set();
        (STATE.existingFields || []).forEach(row=>{
          if(row.field && row.field.id) fieldIds.add(row.field.id);
        });
        (STATE.pendingFields || []).forEach(row=>{
          if(row.field && row.field.id) fieldIds.add(row.field.id);
        });

        if(fieldIds.size === 0){
          diag('overlap.skip', { reason: 'no fieldIds yet' });
          renderOverlapConflicts([]);
          return;
        }

        const targetCropYear = STATE.trial.cropYear;
        const trialsSnap = await getDocs(collection(STATE.db, CONFIG.COLLECTION_TRIALS));
        const relevantTrials = [];

        trialsSnap.forEach(d=>{
          const data = d.data() || {};
          const id   = d.id;
          if(id === STATE.trialId) return;

          const cropYear = data.cropYear;
          if(cropYear !== targetCropYear) return;

          if(STATE.orgId && data.orgId && data.orgId !== STATE.orgId) return;

          const statusRaw = (data.status || '').toString();
          const status = statusRaw.toLowerCase();
          if(!['pending','active','completed'].includes(status)) return;

          relevantTrials.push({
            id,
            trialName: data.trialName || 'Unnamed trial',
            statusRaw,
            status,
            cropYear,
            operationTask: data.operationTask || '',
          });
        });

        diag('overlap.trialsFiltered', {
          totalTrials: trialsSnap.size,
          relevantTrials: relevantTrials.length,
          cropYear: targetCropYear
        });

        if(!relevantTrials.length){
          renderOverlapConflicts([]);
          return;
        }

        const conflicts = [];
        const seen = new Set();

        for(const t of relevantTrials){
          const path = `${CONFIG.COLLECTION_TRIALS}/${t.id}/fields`;
          const fieldsSnap = await getDocs(collection(STATE.db, path));
          fieldsSnap.forEach(fd=>{
            const fdata = fd.data() || {};
            const fieldId = fdata.fieldId || null;
            if(!fieldId || !fieldIds.has(fieldId)) return;

            const key = `${t.id}::${fieldId}`;
            if(seen.has(key)) return;
            seen.add(key);

            const farmName  = fdata.farmName || 'Unknown farm';
            const fieldName = fdata.fieldName || 'Unknown field';

            const niceStatus = t.statusRaw
              ? (t.statusRaw[0].toUpperCase() + t.statusRaw.slice(1))
              : 'Unknown';

            conflicts.push({
              trialId: t.id,
              trialName: t.trialName,
              statusLabel: niceStatus,
              cropYear: t.cropYear,
              farmName,
              fieldName,
              operation: t.operationTask || ''
            });
          });
        }

        diag('overlap.conflicts', { count: conflicts.length });
        renderOverlapConflicts(conflicts);
      }catch(err){
        console.error('Error checking overlapping trials:', err);
        diag('overlap.error', { message: err.message, stack: err.stack });
        renderOverlapConflicts([]);
      }
    }

    // === MH guardrails: allow exactly one field (saved or pending) for multi-hybrid trials ===
    function updateMHGuardrails(){
      const isMH = isMultiHybridTrial();
      const existingCount = (STATE.existingFields || []).length;
      const pendingCount  = (STATE.pendingFields || []).length;
      const totalCount    = existingCount + pendingCount;

      if(!addFieldFormEl && !btnAddFieldEl && !btnSaveFieldsEl){
        return;
      }

      if(!isMH){
        // Non-MH: everything behaves normally.
        if(addFieldFormEl) addFieldFormEl.classList.remove('is-locked');
        if(btnAddFieldEl) btnAddFieldEl.disabled = false;
        if(btnSaveFieldsEl) btnSaveFieldsEl.disabled = false;
        return;
      }

      // MH trial logic: exactly one field at a time (saved OR pending)
      const hasPending = pendingCount > 0;

      if(totalCount >= 1){
        // Lock the Add Field form (can't add a second field)
        if(addFieldFormEl) addFieldFormEl.classList.add('is-locked');
        if(btnAddFieldEl) btnAddFieldEl.disabled = true;
      }else{
        // No fields at all yet — form fully open
        if(addFieldFormEl) addFieldFormEl.classList.remove('is-locked');
        if(btnAddFieldEl) btnAddFieldEl.disabled = false;
      }

      // Save button: only enabled when there is something pending to save
      if(btnSaveFieldsEl){
        btnSaveFieldsEl.disabled = !hasPending;
      }

      diag('updateMHGuardrails', {
        isMH,
        existingCount,
        pendingCount,
        totalCount,
        formLocked: totalCount >= 1
      });
    }

    function renderFieldLists(){
      if(!existingListEl || !pendingListEl) return;

      existingListEl.innerHTML = '';
      if(STATE.existingFields.length){
        const frag = document.createDocumentFragment();
        const label = document.createElement('div');
        label.className = 'field-list-label';
        label.textContent = 'Already saved fields';
        frag.appendChild(label);

        STATE.existingFields.forEach((row,idx)=>{
          const item = document.createElement('div');
          item.className = 'fv-swipe-item';
          item.dataset.kind = 'existing';
          item.dataset.index = String(idx);

          const div = document.createElement('div');
          div.className = 'field-card';
          const farmField = `${row.farm.name} • ${row.field.fieldName}`;
          const acresText = row.acres!=null ? `${row.acres.toFixed(2)} ac` : '—';
          div.innerHTML = `
            <div class="field-card-top">
              <div>
                <div class="field-card-title">${farmField}</div>
                <div class="field-card-sub">
                  Trial acres: <strong>${acresText}</strong>
                  ${row.field.tillable!=null?` (Max tillable: ${row.field.tillable})`:''}
                </div>
              </div>
              <div class="field-card-actions">
                <button type="button" class="btn btn-small" data-existing-yield="${idx}">Add Yield</button>
                <button type="button" class="btn btn-small btn-danger" data-existing-idx="${idx}">Remove</button>
              </div>
            </div>
            ${row.notes?`<div class="field-card-note">${row.notes}</div>`:''}
          `;

          item.appendChild(div);
          frag.appendChild(item);
        });

        existingListEl.appendChild(frag);
      }

      pendingListEl.innerHTML = '';
      if(STATE.pendingFields.length){
        const label = document.createElement('div');
        label.className = 'field-list-label';
        label.textContent = 'New fields (pending save)';
        pendingListEl.appendChild(label);

        STATE.pendingFields.forEach((row,idx)=>{
          const item = document.createElement('div');
          item.className = 'fv-swipe-item';
          item.dataset.kind = 'pending';
          item.dataset.index = String(idx);

          const div=document.createElement('div');
          div.className='field-card';
          const farmField=`${row.farm.name} • ${row.field.fieldName}`;
          const acresText=row.acres!=null?`${row.acres.toFixed(2)} ac`:'—';
          div.innerHTML=`
            <div class="field-card-top">
              <div>
                <div class="field-card-title">${farmField}</div>
                <div class="field-card-sub">
                  Trial acres: <strong>${acresText}</strong>
                  ${row.field.tillable!=null?` (Max tillable: ${row.field.tillable})`:''}
                </div>
              </div>
              <div class="field-card-actions">
                <button type="button" class="btn btn-small" data-pending-yield="${idx}">Add Yield</button>
                <button type="button" class="btn btn-small btn-danger" data-pending-idx="${idx}">Remove</button>
              </div>
            </div>
            ${row.notes?`<div class="field-card-note">${row.notes}</div>`:''}
          `;

          item.appendChild(div);
          pendingListEl.appendChild(item);
        });
      }else{
        if(!STATE.existingFields.length){
          pendingListEl.innerHTML =
            `<div class="field-list-empty">No fields added yet. Use <strong>Add Field</strong> above to start building this trial.</div>`;
        }else{
          pendingListEl.innerHTML =
            `<div class="field-list-empty">No new fields added yet. Use <strong>Add Field</strong> above to add more fields to this trial.</div>`;
        }
      }

      applySwipeToLists();

      // Re-evaluate MH guardrails every time the lists change
      updateMHGuardrails();

      if(overlapCheckTimer) clearTimeout(overlapCheckTimer);
      overlapCheckTimer = setTimeout(()=>{
        checkOverlappingTrials().catch(()=>{});
      }, 120);
    }

    function formHasUnsavedStuff(){
      if(STATE.pendingFields.length) return true;
      if(trialAcresInput && trialAcresInput.value.trim()) return true;
      if(notesInput && notesInput.value.trim()) return true;
      if(STATE.selectedFarm || STATE.selectedField) return true;
      return false;
    }

    function handleNavBack(){
      if(!formHasUnsavedStuff()){
        window.location.href = CONFIG.RETURN_URL;
        return;
      }
      const now = Date.now();
      if(now - lastNavTime < 2500){
        window.location.href = CONFIG.RETURN_URL;
      }else{
        lastNavTime = now;
        showToast("You have unsaved fields. Tap again to discard and go back.");
      }
    }

    function actuallyAddPendingRow(draft){
      const { farm, field, acres, notes } = draft;
      STATE.pendingFields.push({ farm, field, acres, notes });
      sortFieldRows(STATE.pendingFields);
      diag('addFieldToPending', {
        farmId: farm.id,
        fieldId: field.id,
        acres,
        notesLen: (notes || '').length
      });
      renderFieldLists();
      showToast("Field added. Save fields when you're done.");

      STATE.selectedFarm = null;
      STATE.selectedField = null;
      STATE.selectedFieldMaxAcres = null;
      refreshFarmCombo();
      refreshFieldComboForFarm(null);
      if(trialAcresInput){
        trialAcresInput.value = '';
      }
      if(trialAcresHelp){
        trialAcresHelp.textContent = '';
      }
      if(notesInput){
        notesInput.value = '';
      }
    }

    function addFieldToPending(e){
      e.preventDefault();
      showError('');
      if(trialAcresInput) trialAcresInput.classList.remove('input-error');

      // MH hard guard: never allow adding a 2nd field
      if(isMultiHybridTrial()){
        const totalCount = (STATE.existingFields || []).length + (STATE.pendingFields || []).length;
        if(totalCount >= 1){
          showError("Multiple-hybrid trials can only have one field. Remove the existing field before adding another.");
          showToast("MH trial: only one field allowed.");
          return;
        }
      }

      const farm = STATE.selectedFarm;
      const field = STATE.selectedField;
      if(!farm){
        showError("Please select a farm.");
        return;
      }
      if(!field){
        showError("Please select a field.");
        return;
      }
      if(field.farmId && field.farmId!==farm.id){
        showError("Selected field does not belong to the selected farm. Please choose a matching farm and field.");
        return;
      }

      const fieldId = field.id;
      if(fieldId){
        const alreadyExisting = STATE.existingFields.some(row => row.field && row.field.id === fieldId);
        const alreadyPending  = STATE.pendingFields.some(row => row.field && row.field.id === fieldId);
        if(alreadyExisting || alreadyPending){
          showError("This field is already in this trial. You can't add the same field twice.");
          showToast("Field already added to this trial.");
          return;
        }
      }

      const acresStr = trialAcresInput ? trialAcresInput.value.trim() : '';
      const notes    = notesInput ? notesInput.value.trim() : '';
      let acres;

      if(!acresStr){
        showError("Trial acres are required. Enter acres for this field before adding it.");
        if(trialAcresInput) trialAcresInput.classList.add('input-error');
        return;
      }

      acres = Number(acresStr);
      if(isNaN(acres)){
        showError("Trial acres must be a number.");
        if(trialAcresInput) trialAcresInput.classList.add('input-error');
        return;
      }
      acres = Math.round(acres * 100) / 100;

      const maxAcres = STATE.selectedFieldMaxAcres;
      if(maxAcres != null && acres > maxAcres + 0.0001){
        showError(`Trial acres cannot be more than the field tillable acres (${maxAcres}).`);
        if(trialAcresInput) trialAcresInput.classList.add('input-error');
        return;
      }

      const draft = { farm, field, acres, notes };

      actuallyAddPendingRow(draft);
    }

    async function saveAllFields(e){
      e.preventDefault();
      showError('');
      if(trialAcresInput) trialAcresInput.classList.remove('input-error');

      if(!STATE.pendingFields.length){
        showError("No new fields to save. Add at least one field to this trial.");
        return;
      }
      if(!STATE.user){
        showError("User is not signed in. Please re-login and try again.");
        return;
      }

      // MH safety net: prevent saving if somehow more than one field exists+pending
      if(isMultiHybridTrial()){
        const existingCount = (STATE.existingFields || []).length;
        const pendingCount  = (STATE.pendingFields || []).length;
        const totalCount    = existingCount + pendingCount;
        if(totalCount > 1){
          showError("Multiple-hybrid trials can only have one field. Remove extra fields before saving.");
          if(btnSaveFieldsEl) btnSaveFieldsEl.disabled = true;
          return;
        }
      }

      const saveBtn = btnSaveFieldsEl || document.getElementById('btnSaveFields');
      if(saveBtn) saveBtn.disabled=true;

      try{
        const trialId = STATE.trialId;
        const basePath = `${CONFIG.COLLECTION_TRIALS}/${trialId}/fields`;
        const fieldsCollRef = collection(STATE.db, CONFIG.COLLECTION_TRIALS, trialId, 'fields');

        diag('saveAllFields.start', {
          trialId,
          basePath,
          pendingCount: STATE.pendingFields.length,
          userUid: STATE.user.uid,
          orgId: STATE.orgId
        });

        // Write each pending field doc directly to the subcollection
        for(const row of STATE.pendingFields){
          const payload = {
            farmId: row.farm.id,
            farmName: row.farm.name,
            fieldId: row.field.id,
            fieldName: row.field.fieldName,
            tillable: row.field.tillable!=null?row.field.tillable:null,
            trialAcres: row.acres!=null?row.acres:null,
            notes: row.notes || null
          };
          diag('saveAllFields.addDoc', {
            path: basePath,
            payload
          });
          await addDoc(fieldsCollRef, payload);
        }

        // Mark the trial Active using FVData (top-level doc, same behavior as before)
        diag('saveAllFields.updateTrial', { path: `${CONFIG.COLLECTION_TRIALS}/${trialId}` });
        await FVData.updateDocWithMeta(
          `${CONFIG.COLLECTION_TRIALS}/${trialId}`,
          { status: 'active' }
        );

        diag('saveAllFields.success', {});
        showToast("Fields saved and trial marked Active.");
        setTimeout(()=>{ window.location.href=CONFIG.RETURN_URL; },800);
      }catch(err){
        console.error("Error saving fields:",err);
        diag('saveAllFields.error', {
          code: err.code,
          message: err.message,
          stack: err.stack
        });
        showError("Error saving fields: "+(err && (err.message||err.code) || "Unknown error"));
        const saveBtn2=btnSaveFieldsEl || document.getElementById('btnSaveFields');
        if(saveBtn2) saveBtn2.disabled=false;
      }
    }

    (async function boot(){
      await ready;

      toastEl=document.getElementById('toast');
      errorBox=document.getElementById('errBox');
      debugLogEl=document.getElementById('debugLog');

      overlapHeroEl   = document.getElementById('overlapHero');
      overlapListEl   = document.getElementById('overlapList');
      overlapSummaryEl= document.getElementById('overlapSummary');
      overlapBadgeEl  = document.getElementById('overlapBadge');

      if(overlapHeroEl){
        overlapHeroEl.style.display = 'none';
      }

      addFieldFormEl  = document.getElementById('addFieldForm');

      diag('boot.start', { href: window.location.href });

      STATE.auth = getAuth();
      STATE.user = await waitForAuthReady();

      if(STATE.user){
        diag('boot.user', { uid: STATE.user.uid, email: STATE.user.email });
      }else{
        diag('boot.user.missing', {});
      }

      STATE.trialId=getQueryParam('trialId');
      diag('boot.trialId', { trialId: STATE.trialId });

      const shell=document.querySelector('fv-shell');
      if(shell && NAV_MENU) shell.nav=NAV_MENU;

      if(!STATE.trialId){
        showError("Missing trialId in URL. Use this page from the Trials screen.");
        return;
      }

      if(!STATE.user){
        showError("User is not signed in. Please log in again.");
        return;
      }

      const fvUser = await waitForFVUser();
      diag('boot.fvUser', fvUser || { missing:true });
      if(!fvUser){
        showError("Unable to load user info. Please refresh.");
        return;
      }

      STATE.fvUser = fvUser;
      STATE.orgId  = fvUser.orgId || fvUser.org || fvUser.orgID || null;
      diag('boot.orgId', { orgId: STATE.orgId });

      STATE.db=getFirestore();

      trialNameMain      = document.getElementById("trialNameMain");
      trialCropMain      = document.getElementById("trialCropMain");
      trialTypeLine      = document.getElementById("trialTypeLine");
      trialTreatmentLine = document.getElementById("trialTreatmentLine");

      fieldFarmBtn    = document.getElementById("fieldFarmBtn");
      fieldFarmPanel  = document.getElementById("fieldFarmPanel");
      fieldFarmList   = document.getElementById("fieldFarmList");
      fieldFarmSearch = document.getElementById("fieldFarmSearch");

      fieldFieldBtn   = document.getElementById("fieldFieldBtn");
      fieldFieldPanel = document.getElementById("fieldFieldPanel");
      fieldFieldList  = document.getElementById("fieldFieldList");
      fieldFieldSearch= document.getElementById("fieldFieldSearch");

      trialAcresInput = document.getElementById("trialAcres");
      trialAcresHelp  = document.getElementById("trialAcresHelp");
      notesInput      = document.getElementById("notes");
      micBtn          = document.getElementById("notesMic");

      existingListEl  = document.getElementById("existingFieldList");
      pendingListEl   = document.getElementById("pendingFieldList");

      const btnBack     = document.getElementById("btnBack");
      const btnAddField = document.getElementById("btnAddField");
      const btnSaveAll  = document.getElementById("btnSaveFields");
      const btnCancel   = document.getElementById("btnCancel");

      btnAddFieldEl   = btnAddField || null;
      btnSaveFieldsEl = btnSaveAll  || null;

      if(btnBack){
        btnBack.addEventListener("click", handleNavBack);
      }
      if(btnCancel){
        btnCancel.addEventListener("click", handleNavBack);
      }
      if(btnAddField){
        btnAddField.addEventListener("click", addFieldToPending);
      }
      if(btnSaveAll){
        btnSaveAll.addEventListener("click", saveAllFields);
      }

      if(existingListEl){
        existingListEl.addEventListener('click', (e)=>{
          const yieldBtn = e.target.closest('button[data-existing-yield]');
          if(yieldBtn){
            const idx = Number(yieldBtn.getAttribute('data-existing-yield'));
            if(!Number.isNaN(idx)) openYieldForExisting(idx);
            return;
          }
          const removeBtn = e.target.closest('button[data-existing-idx]');
          if(removeBtn){
            const idx = Number(removeBtn.getAttribute('data-existing-idx'));
            if(!Number.isNaN(idx)) removeExistingField(idx);
          }
        });
      }

      if(pendingListEl){
        pendingListEl.addEventListener('click', (e)=>{
          const yieldBtn = e.target.closest('button[data-pending-yield]');
          if(yieldBtn){
            openYieldForPending();
            return;
          }
          const removeBtn = e.target.closest('button[data-pending-idx]');
          if(removeBtn){
            const idx = Number(removeBtn.getAttribute('data-pending-idx'));
            if(!Number.isNaN(idx)) removePendingField(idx);
          }
        });
      }

      if(trialAcresInput){
        trialAcresInput.addEventListener("blur", ()=>{
          const v=trialAcresInput.value.trim();
          if(!v) return;
          const n=Number(v);
          if(!isNaN(n)) trialAcresInput.value=(Math.round(n*100)/100).toFixed(2);
        });
      }

      // mic wiring – same pattern as maintenance-add
      setupMic();

      farmCombo = makeCombo({
        btn:fieldFarmBtn,
        panel:fieldFarmPanel,
        list:fieldFarmList,
        searchInput:fieldFarmSearch,
        searchable:true,
        formatter:x=>x.label,
        onPick:f=>{
          STATE.selectedFarm=STATE.farms.find(ff=>ff.id===f.id)||null;
          refreshFieldComboForFarm(f.id);
        }
      });

      fieldCombo = makeCombo({
        btn:fieldFieldBtn,
        panel:fieldFieldPanel,
        list:fieldFieldList,
        searchInput:fieldFieldSearch,
        searchable:true,
        formatter:x=>x.label,
        onPick:item=>{
          STATE.selectedField=item.raw;
          if(item.raw.farmId){
            const farm=STATE.farms.find(f=>f.id===item.raw.farmId);
            if(farm){
              STATE.selectedFarm=farm;
              refreshFieldComboForFarm(farm.id);
              STATE.selectedField=item.raw;
              if(fieldFieldBtn) fieldFieldBtn.textContent=item.label;
            }else if(fieldFieldBtn){
              fieldFieldBtn.textContent=item.label;
            }
          }else if(fieldFieldBtn){
            fieldFieldBtn.textContent=item.label;
          }
          const max=item.raw.tillable!=null?item.raw.tillable:null;
          STATE.selectedFieldMaxAcres=max;
          if(max!=null && trialAcresHelp){
            trialAcresHelp.textContent=
              `Max trial acres for this field: ${max}. Trial acres cannot be more than the tillable acres.`;
          }else if(trialAcresHelp){
            trialAcresHelp.textContent='';
          }
        }
      });

      try{
        await loadTrial();
        // As soon as trial is known, update MH guardrails once (will re-run after lists render too)
        updateMHGuardrails();
        await loadFarmsAndFields();
      }catch(err){
        console.error("Initial load error:",err);
        diag('boot.load.error', { code: err.code, message: err.message });
        showError("Error loading data. Some lists may be incomplete.");
      }

      refreshFarmCombo();
      refreshFieldComboForFarm(null);

      // Attach live listener for existing trial fields
      attachTrialFieldsListener();

      // BFCache / visibility / focus handling similar to equipment page
      window.addEventListener('pageshow', () => {
        resume();
      });

      document.addEventListener('visibilitychange', () => {
        if(document.visibilityState === 'visible'){
          resume();
        }
      });

      window.addEventListener('focus', () => {
        resume();
      });

      window.addEventListener('pagehide', () => {
        detachTrialFieldsListener();
      });

      renderFieldLists();
      diag('boot.complete', {});
    })();
  </script>
</head>

<body>
  <fv-shell>
    <div class="wrap">
      <section class="hero">
        <header class="hero-head">
          <div class="hero-head-main">
            <div class="icon" aria-hidden="true">🧪</div>
            <div>
              <h1>Add Field to Trial</h1>
              <p class="muted">
                Pick a farm and field, then enter the acres that are part of this trial. Trial acres can’t be more
                than the field’s tillable acres.
              </p>
            </div>
          </div>
        </header>

        <div class="body">
          <div id="errBox" class="error-box"></div>

          <div class="top-row">
            <button id="btnBack" type="button" class="btn btn-quiet">
              ← Back to Trials
            </button>
          </div>

          <div class="top-row">
            <div class="trial-summary">
              <div class="trial-summary-title" id="trialNameMain">Loading trial…</div>
              <div class="trial-summary-line">
                <strong>Crop:</strong> <span id="trialCropMain">—</span>
              </div>
              <div class="trial-summary-line" id="trialTypeLine"></div>
              <div class="trial-summary-line" id="trialTreatmentLine"></div>
            </div>
          </div>

          <!-- Add Field form (locked for MH when a field already exists) -->
          <div id="addFieldForm">
            <div class="row">
              <div class="field combo">
                <label for="fieldFarmBtn">Farm</label>
                <div class="combo-anchor">
                  <button id="fieldFarmBtn" class="buttonish has-caret" type="button">
                    — Select farm —</button>
                  <div id="fieldFarmPanel" class="combo-panel" role="listbox" aria-label="Farm list">
                    <div class="search">
                      <input id="fieldFarmSearch" type="search" placeholder="Search farms…" />
                    </div>
                    <div class="list" id="fieldFarmList"></div>
                  </div>
                </div>
                <div class="helper">Pick the farm where this trial strip is located.</div>
              </div>

              <div class="field combo">
                <label for="fieldFieldBtn">Field</label>
                <div class="combo-anchor">
                  <button id="fieldFieldBtn" class="buttonish has-caret" type="button">
                    — Select field —</button>
                  <div id="fieldFieldPanel" class="combo-panel" role="listbox" aria-label="Field list">
                    <div class="search">
                      <input id="fieldFieldSearch" type="search" placeholder="Search fields…" />
                    </div>
                    <div class="list" id="fieldFieldList"></div>
                  </div>
                </div>
                <div class="helper">You can pick a field first and the farm will auto-fill.</div>
              </div>
            </div>

            <div class="field">
              <label for="trialAcres">Trial Acres</label>
              <input
                id="trialAcres"
                class="input no-spin"
                type="number"
                step="0.01"
                required
                placeholder="Acres in this field that are part of the trial"
              />
              <div id="trialAcresHelp" class="helper"></div>
            </div>

            <div class="field">
              <label for="notes">Notes</label>
              <div class="ta-wrap">
                <textarea id="notes" class="textarea with-mic"
                          placeholder="Strip layout, passes, timing, or anything the crew needs to remember."></textarea>
                <button id="notesMic" type="button" class="mic-btn" aria-label="Start dictation">
                  <svg class="mic-svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                    <path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 1 0-6 0v5a3 3 0 0 0 3 3zm5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 6 6.92V21H9v2h6v-2h-2v-3.08A7 7 0 0 0 19 11h-2z"/>
                  </svg>
                </button>
              </div>
              <div class="helper">Optional, but really helpful when you come back to review results.</div>
            </div>

            <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:4px;">
              <button id="btnAddField" type="button" class="btn btn-primary">
                Add Field
              </button>
            </div>
          </div>
        </div>
      </section>

      <section class="fields-hero">
        <header class="fields-head">
          <h2>Fields in this trial</h2>
        </header>
        <div class="fields-body">
          <div id="existingFieldList"></div>
          <div id="pendingFieldList"></div>
          <div class="fields-swipe-hint">
            On a phone, swipe right on a field card to add yield, and swipe left to remove it from this list. On desktop, use the buttons.
          </div>
        </div>
        <div class="fields-actions">
          <button id="btnCancel" type="button" class="btn">Cancel</button>
          <button id="btnSaveFields" type="button" class="btn btn-primary">Save Fields</button>
        </div>
      </section>

      <section id="overlapHero" class="overlap-hero" style="display:none;">
        <header class="overlap-head">
          <h2>Other trials using these fields</h2>
          <span id="overlapBadge" class="overlap-badge"></span>
        </header>
        <div class="overlap-body">
          <div id="overlapSummary" class="overlap-summary"></div>
          <div id="overlapList"></div>
        </div>
      </section>
    </div>
  </fv-shell>

  <div id="toast" class="toast" role="status" aria-live="polite">Saved.</div>
</body>
</html>
