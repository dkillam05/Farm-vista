<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FarmVista â€¢ Expenditures â€“ Add</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#3B7E46" />

  <link rel="manifest" href="/Farm-vista/manifest.webmanifest" />
  <link rel="apple-touch-icon" href="/Farm-vista/assets/icons/apple-touch-icon.png" />
  <link rel="icon" href="/Farm-vista/assets/icons/icon-192.png" />
  <script src="/Farm-vista/js/theme-boot.js"></script>
  <link rel="stylesheet" href="/Farm-vista/assets/css/theme.css" />
  <link rel="stylesheet" href="/Farm-vista/assets/css/app.css" />

  <!-- (Left in place, but not used directly now) -->
  <script defer src="/Farm-vista/js/ocr-tesseract.js"></script>
  <!-- fv-combo for Submitted By -->
  <script defer src="/Farm-vista/js/fv-combo.js"></script>

  <style>
    .section {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--surface);
      box-shadow: var(--shadow, 0 8px 20px rgba(0, 0, 0, .08));
    }
    .section-head {
      display: grid;
      grid-template-columns: 36px 1fr;
      gap: 12px;
      align-items: center;
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(90deg, rgba(47, 108, 60, .12), transparent);
    }
    .section-head .icon {
      width: 24px;
      height: 24px;
      color: #2F6C3C;
      display: grid;
      place-items: center;
    }
    .section-body {
      padding: 16px;
      display: grid;
      gap: 14px;
    }

    .grid-2 {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr 1fr;
    }
    .grid-3 {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr 1fr 1fr;
    }
    @media (max-width: 880px) {
      .grid-2,
      .grid-3 {
        grid-template-columns: 1fr;
      }
    }

    .field label {
      display: block;
      font-weight: 800;
      margin: 0 0 6px 0;
    }
    .field label .req {
      color: #b3261e;
      margin-left: 3px;
    }
    .input,
    .select,
    .textarea {
      width: 100%;
      font: inherit;
      font-size: 16px;
      color: var(--text);
      background: var(--card-surface, var(--surface));
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      outline: none;
    }
    .textarea {
      min-height: 96px;
      resize: vertical;
    }

    .rc-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 140px;
      padding: 12px 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--card-surface, var(--surface));
      font-weight: 800;
      color: var(--text);
      cursor: pointer;
    }
    .btn-primary {
      border-color: transparent;
      background: #2F6C3C;
      color: #fff;
    }
    .linklike {
      border: 0;
      background: none;
      color: var(--accent, #2F6C3C);
      font-weight: 700;
      cursor: pointer;
      padding: 0;
    }

    #preview[hidden] {
      display: none !important;
    }
    .thumb {
      width: 120px;
      height: 120px;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      display: grid;
      place-items: center;
      background: #f6f7f6;
    }
    .thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .help {
      font-size: 13px;
      color: var(--muted, #67706B);
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 72px);
      transform: translateX(-50%);
      background: #2F6C3C;
      color: #fff;
      padding: 10px 14px;
      border-radius: 10px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .25);
      z-index: 99999;
      display: none;
    }
    .toast.show {
      display: block;
      animation: fadeout 2.8s forwards;
    }
    @keyframes fadeout {
      0% { opacity: 1 }
      85% { opacity: 1 }
      100% { opacity: 0 }
    }
    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: clamp(14px, 3vw, 22px);
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + var(--ftr-h, 42px) + 96px) !important;
    }
    .page-title { margin: 0 0 8px 0; }
    .page-sub {
      margin: 0 0 14px 0;
      color: var(--muted, #67706B);
    }

    /* Camera modal + framing box (mobile-deposit style) */
    .camera-modal[hidden] {
      display: none !important;
    }
    .camera-modal {
      position: fixed;
      inset: 0;
      z-index: 99990;
      display: grid;
      place-items: center;
    }
    .camera-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
    }
    .camera-shell {
      position: relative;
      width: min(100vw, 480px);
      max-height: 90vh;
      border-radius: 18px;
      overflow: hidden;
      background: #000;
      display: flex;
      flex-direction: column;
    }
    .camera-header {
      padding: 8px 12px;
      color: #fff;
      font-weight: 700;
      font-size: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(90deg, rgba(0,0,0,.9), rgba(0,0,0,.5));
      z-index: 2;
    }
    .camera-header button {
      border: 0;
      background: none;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      font-weight: 600;
    }
    .camera-body {
      position: relative;
      flex: 1;
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    #cameraVideo {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .camera-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .camera-frame {
      width: 80%;
      max-width: 360px;
      aspect-ratio: 3 / 2;
      border-radius: 12px;
      box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(255, 255, 255, 0.9);
      transition: border-color .25s ease, box-shadow .25s ease;
    }
    .camera-frame.stable {
      border-color: #7CFC7C;
      box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.35);
    }
    .camera-hints {
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #f1f1f1;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.65);
      max-width: 90%;
    }
    .camera-footer {
      padding: 8px 12px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #fff;
      font-size: 13px;
      background: linear-gradient(0deg, rgba(0,0,0,.9), rgba(0,0,0,.5));
      gap: 8px;
    }
    .camera-footer-left {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-width: 60%;
    }
    .torch-toggle {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 4px 10px;
      background: rgba(0, 0, 0, 0.4);
      color: #fff;
      cursor: pointer;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .torch-toggle[hidden] {
      display: none;
    }
    .torch-toggle.active {
      background: #2F6C3C;
      border-color: #2F6C3C;
    }
    .torch-note {
      font-size: 11px;
      opacity: .85;
    }
    .camera-footer-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .camera-capture-btn {
      width: 54px;
      height: 54px;
      border-radius: 50%;
      border: 3px solid #fff;
      background: transparent;
      display: grid;
      place-items: center;
      cursor: pointer;
      position: relative;
    }
    .camera-capture-btn::before {
      content: "";
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background: #fff;
    }
    .camera-cancel {
      border: 0;
      background: none;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      padding: 4px 6px;
    }
  </style>

  <script>
    (function () {
      if (!customElements.get('fv-shell')) {
        const s = document.createElement('script');
        s.src = '/Farm-vista/js/fv-shell.js';
        s.defer = true;
        document.head.appendChild(s);
      }
    })();
  </script>
</head>
<body>
  <fv-shell>
    <div class="page container">
      <h1 class="page-title">New Expenditure</h1>
      <p class="page-sub">
        Take a photo or import your receipt and weâ€™ll read it automatically.
        You can edit any field before saving.
      </p>

      <section class="section">
        <header class="section-head">
          <div class="icon" aria-hidden="true">
            <!-- Tabler (MIT) receipt icon -->
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                 stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
              <path d="M5 4h14v16l-2 -1l-2 1l-2 -1l-2 1l-2 -1l-2 1z" />
              <path d="M14 8h-4M14 12h-4" />
            </svg>
          </div>
          <div>
            <strong>Receipt</strong>
            <div class="help">Choose one: Take Photo or Import. OCR will auto-run (cloud-based).</div>
          </div>
        </header>

        <div class="section-body">
          <!-- Camera / import -->
          <div class="rc-actions">
            <button id="btnTake" class="btn" type="button">Take Photo</button>
            <button id="btnImport" class="btn" type="button">Import</button>
            <button id="btnReplace" class="linklike" type="button" hidden>Replace</button>
          </div>

          <div id="preview" hidden>
            <div id="thumb" class="thumb" aria-live="polite"></div>
            <div id="ocrStatus" class="help"></div>
          </div>

          <!-- hidden inputs (fallbacks) -->
          <input id="camInput" type="file" accept="image/*,.pdf" capture="environment" hidden>
          <input id="fileInput" type="file" accept="image/*,.pdf" hidden>

          <!-- Row 1: Submitted By + Submitted Date -->
          <div class="grid-2">
            <div class="field">
              <label for="whoSel">Submitted By<span class="req">*</span></label>
              <select id="whoSel" class="select" data-fv-combo data-fv-search="true">
                <option value="">Loading employeesâ€¦</option>
              </select>
            </div>
            <div class="field">
              <label for="submitted">Submitted Date<span class="req">*</span></label>
              <input id="submitted" class="input" type="date">
            </div>
          </div>

          <!-- Row 2: Payment Method + Category -->
          <div class="grid-2">
            <div class="field">
              <label for="paymethod">Payment Method<span class="req">*</span></label>
              <select id="paymethod" class="select">
                <option value="">â€”</option>
                <option value="reimb">Out-of-pocket (reimburse)</option>
                <option value="card">Company card</option>
              </select>
            </div>
            <div class="field">
              <label for="category">Category<span class="req">*</span></label>
              <select id="category" class="select">
                <option value="">â€”</option>
                <option>Fuel</option>
                <option>Repairs/Parts</option>
                <option>Supplies</option>
                <option>Meals</option>
                <option>Lodging</option>
                <option>Fees/Tolls</option>
                <option>Other</option>
              </select>
            </div>
          </div>

          <!-- Row 3: Merchant + Total + Receipt Date -->
          <div class="grid-3">
            <div class="field">
              <label for="merchant">Merchant<span class="req">*</span></label>
              <input id="merchant" class="input" placeholder="Store / vendor">
            </div>
            <div class="field">
              <label for="total">Total (USD)<span class="req">*</span></label>
              <input id="total" class="input" inputmode="decimal" placeholder="$0.00">
            </div>
            <div class="field">
              <label for="rdate">Receipt Date<span class="req">*</span></label>
              <input id="rdate" class="input" type="date">
            </div>
          </div>

          <div class="field">
            <label for="project">Project/Field (optional)</label>
            <input id="project" class="input" placeholder="Project, field, or tag">
          </div>

          <div class="field">
            <label for="notes">Notes (optional)</label>
            <textarea id="notes" class="textarea" placeholder="Anything helpful for accountingâ€¦"></textarea>
          </div>

          <div class="rc-actions">
            <button id="btnClear" class="btn" type="button">Clear</button>
            <button id="btnSave" class="btn btn-primary" type="button">Save</button>
          </div>
        </div>
      </section>
    </div>
  </fv-shell>

  <!-- Camera modal (mobile-deposit style) -->
  <div id="cameraModal" class="camera-modal" hidden>
    <div class="camera-backdrop"></div>
    <div class="camera-shell" role="dialog" aria-modal="true" aria-labelledby="cameraTitle">
      <div class="camera-header">
        <span id="cameraTitle">Align receipt inside the box</span>
        <button type="button" id="cameraCloseTop">Close</button>
      </div>
      <div class="camera-body">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <div class="camera-overlay">
          <div id="cameraFrame" class="camera-frame"></div>
        </div>
        <div class="camera-hints">
          Use rear camera, keep the receipt centered and hold steady. The box will glow when the view is stable.
        </div>
      </div>
      <div class="camera-footer">
        <div class="camera-footer-left">
          <button id="torchToggle" class="torch-toggle" type="button" hidden>
            ðŸ”¦ <span id="torchLabel">Flashlight</span>
          </button>
          <div id="torchNote" class="torch-note"></div>
        </div>
        <div class="camera-footer-right">
          <button id="cameraCancel" class="camera-cancel" type="button">Cancel</button>
          <button id="cameraCapture" class="camera-capture-btn" type="button" aria-label="Capture photo"></button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite">Saved.</div>

  <script>
  (function () {
    "use strict";

    const OCR_URL = "https://fv-ocr-300398089669.us-central1.run.app/fvOcr";

    const firebase = window.firebase || {};
    const $ = id => document.getElementById(id);
    const todayISO = () =>
      new Date(Date.now() - new Date().getTimezoneOffset() * 60000)
        .toISOString().slice(0, 10);

    const whoSel   = $("whoSel"),
          submitted = $("submitted"),
          merchant  = $("merchant"),
          rdate     = $("rdate"),
          category  = $("category"),
          total     = $("total"),
          paymethod = $("paymethod"),
          project   = $("project"),
          notes     = $("notes");

    submitted.value = todayISO();

    /* USD formatting */
    const usdFmt = new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD"
    });
    const parseUSD = str => {
      if (!str) return "";
      const n = Number(String(str).replace(/[^0-9.-]/g, ""));
      return isFinite(n) ? n : "";
    };
    total.addEventListener("blur", e => {
      const v = parseUSD(e.target.value);
      e.target.value = v === "" ? "" : usdFmt.format(v);
    });

    /* Load employees into Submitted By (fv-combo) â€” same pattern as grain bag form */
    async function loadEmployeesCombo() {
      try {
        const auth = firebase.auth ? firebase.auth() : null;
        const currentUser = auth && auth.currentUser;
        const currentEmail = currentUser && currentUser.email
          ? currentUser.email.toLowerCase()
          : "";
        const currentName =
          (currentUser && (currentUser.displayName || currentUser.email)) ||
          "";

        // Fallback: at minimum, show current user
        function setFallback() {
          whoSel.innerHTML = "";
          if (currentName) {
            whoSel.appendChild(new Option(currentName, currentEmail || currentName));
            whoSel.selectedIndex = 0;
          } else {
            whoSel.appendChild(new Option("Unknown user", ""));
          }
        }

        if (!firebase.firestore) {
          setFallback();
          return;
        }

        const db = firebase.firestore();
        const snap = await db.collection("employees").get();
        const opts = [];

        snap.forEach(doc => {
          const data = doc.data() || {};
          const display =
            data.name ||
            data.displayName ||
            data.fullName ||
            data.employeeName ||
            data.email ||
            doc.id;
          const email = (data.email || doc.id || "").toLowerCase();
          opts.push({
            value: email || doc.id || display,
            label: display
          });
        });

        whoSel.innerHTML = "";
        whoSel.appendChild(new Option("â€” Select â€”", ""));

        opts
          .sort((a, b) => a.label.localeCompare(b.label))
          .forEach(o => {
            whoSel.appendChild(new Option(o.label, o.value));
          });

        // Default to logged-in user if present (same idea as chosen.sub on grain bag)
        if (currentEmail) {
          for (let i = 0; i < whoSel.options.length; i++) {
            const opt = whoSel.options[i];
            if (!opt.value) continue;
            if (opt.value.toLowerCase() === currentEmail) {
              whoSel.selectedIndex = i;
              break;
            }
          }
        }

        // If nothing selected and we still have a current user, collapse to them only
        if (!whoSel.value && currentName) {
          whoSel.innerHTML = "";
          whoSel.appendChild(new Option(currentName, currentEmail || currentName));
          whoSel.selectedIndex = 0;
        }
      } catch (err) {
        console.warn("Failed to load employees for Submitted By:", err);
        // fallback to current user if possible
        const auth = firebase.auth ? firebase.auth() : null;
        const currentUser = auth && auth.currentUser;
        const currentEmail = currentUser && currentUser.email
          ? currentUser.email.toLowerCase()
          : "";
        const currentName =
          (currentUser && (currentUser.displayName || currentUser.email)) ||
          "Unknown user";
        whoSel.innerHTML = "";
        whoSel.appendChild(new Option(currentName, currentEmail || currentName));
        whoSel.selectedIndex = 0;
      }
    }

    function initEmployeesCombo() {
      try {
        const auth = firebase.auth ? firebase.auth() : null;
        if (auth) {
          if (auth.currentUser) {
            loadEmployeesCombo();
          } else {
            auth.onAuthStateChanged(() => {
              loadEmployeesCombo();
            });
          }
        }
      } catch (e) {
        console.warn("initEmployeesCombo error:", e);
      }
    }

    function getSubmittedByName() {
      if (!whoSel) return "";
      const opt = whoSel.options[whoSel.selectedIndex];
      if (opt && opt.text && opt.value) return opt.text.trim();
      if (opt && opt.text) return opt.text.trim();
      return whoSel.value || "";
    }
    function getSubmittedByEmail() {
      if (!whoSel) return "";
      return (whoSel.value || "").trim();
    }

    /* Receipt capture (with camera overlay + torch where supported) */
    const btnTake   = $("btnTake"),
          btnImport = $("btnImport"),
          btnReplace= $("btnReplace");
    const camInput  = $("camInput"),
          fileInput = $("fileInput");
    const preview   = $("preview"),
          thumb     = $("thumb"),
          ocrStatus = $("ocrStatus");
    let file = null;

    // Camera modal elements
    const cameraModal   = $("cameraModal");
    const cameraVideo   = $("cameraVideo");
    const cameraFrame   = $("cameraFrame");
    const cameraCloseTop= $("cameraCloseTop");
    const cameraCancel  = $("cameraCancel");
    const cameraCapture = $("cameraCapture");
    const torchToggle   = $("torchToggle");
    const torchLabel    = $("torchLabel");
    const torchNote     = $("torchNote");

    let camStream = null;
    let camTrack  = null;
    let torchOn   = false;
    let lastFrameTime = 0;
    let lastStableTime = 0;
    let lastCenterBox = null;

    btnTake.addEventListener("click", () => {
      // Try rich camera experience first; fall back to input if not supported.
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        openCameraModal().catch(err => {
          console.warn("Camera modal failed, falling back to input:", err);
          camInput.click();
        });
      } else {
        camInput.click();
      }
    });
    btnImport.addEventListener("click", () => fileInput.click());
    btnReplace.addEventListener("click", () => fileInput.click());

    camInput.addEventListener("change", () => handleFiles(camInput.files));
    fileInput.addEventListener("change", () => handleFiles(fileInput.files));

    async function openCameraModal() {
      torchOn = false;
      if (camStream) {
        stopCameraStream();
      }
      torchToggle.hidden = true;
      torchNote.textContent = "";

      cameraModal.hidden = false;

      try {
        camStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        });
      } catch (err) {
        cameraModal.hidden = true;
        throw err;
      }

      cameraVideo.srcObject = camStream;
      camTrack = camStream.getVideoTracks()[0] || null;

      // Torch capability (Android Chrome mostly; iOS Safari will usually say no)
      try {
        const caps = camTrack && camTrack.getCapabilities ? camTrack.getCapabilities() : null;
        if (caps && "torch" in caps) {
          torchToggle.hidden = false;
          torchOn = false;
          torchLabel.textContent = "Flashlight";
          torchNote.textContent = "";
        } else {
          torchToggle.hidden = true;
          torchNote.textContent = "Flashlight control isnâ€™t available on this device/browser.";
        }
      } catch (e) {
        torchToggle.hidden = true;
        torchNote.textContent = "Flashlight control isnâ€™t available here.";
      }

      // Simple "stability" hint: if video frames are steady, glow the frame.
      lastFrameTime = performance.now();
      lastStableTime = lastFrameTime;
      lastCenterBox = null;
      requestAnimationFrame(checkFrameStability);
    }

    function stopCameraStream() {
      if (camStream) {
        camStream.getTracks().forEach(t => t.stop());
      }
      camStream = null;
      camTrack = null;
      torchOn = false;
      cameraVideo.srcObject = null;
    }

    async function toggleTorch() {
      if (!camTrack) return;
      try {
        const caps = camTrack.getCapabilities ? camTrack.getCapabilities() : null;
        if (!caps || !("torch" in caps)) {
          torchNote.textContent = "Flashlight not supported on this device.";
          return;
        }
        torchOn = !torchOn;
        await camTrack.applyConstraints({ advanced: [{ torch: torchOn }] });
        torchToggle.classList.toggle("active", torchOn);
        torchLabel.textContent = torchOn ? "Flashlight (On)" : "Flashlight";
      } catch (e) {
        console.warn("Torch toggle failed:", e);
        torchNote.textContent = "Could not control flashlight. Your device may not allow it from the browser.";
        torchOn = false;
        torchToggle.classList.remove("active");
      }
    }

    torchToggle.addEventListener("click", toggleTorch);

    function closeCameraModal() {
      stopCameraStream();
      cameraModal.hidden = true;
    }

    cameraCloseTop.addEventListener("click", closeCameraModal);
    cameraCancel.addEventListener("click", closeCameraModal);

    cameraCapture.addEventListener("click", async () => {
      if (!camStream || !cameraVideo.videoWidth || !cameraVideo.videoHeight) {
        return;
      }
      try {
        const canvas = document.createElement("canvas");
        const vw = cameraVideo.videoWidth;
        const vh = cameraVideo.videoHeight;

        // Capture centered region roughly matching the framing box ratio
        const aspect = 3 / 2;
        let cw = vw * 0.8;
        let ch = cw / aspect;
        if (ch > vh) {
          ch = vh * 0.8;
          cw = ch * aspect;
        }
        const cx = (vw - cw) / 2;
        const cy = (vh - ch) / 2;

        canvas.width = cw;
        canvas.height = ch;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(cameraVideo, cx, cy, cw, ch, 0, 0, cw, ch);

        const blob = await new Promise((resolve, reject) => {
          canvas.toBlob(b => b ? resolve(b) : reject(new Error("Capture failed")), "image/jpeg", 0.9);
        });

        const capturedFile = new File([blob], "receipt-camera.jpg", { type: "image/jpeg" });
        closeCameraModal();
        handleFiles([capturedFile]);
      } catch (err) {
        console.error("Camera capture failed:", err);
        closeCameraModal();
      }
    });

    // Very lightweight "stability" signal: if view hasn't resized recently, mark frame as stable.
    function checkFrameStability(now) {
      if (!camStream || cameraModal.hidden) return;
      const rect = cameraFrame.getBoundingClientRect();
      const box = { w: rect.width, h: rect.height };
      if (lastCenterBox) {
        const dw = Math.abs(box.w - lastCenterBox.w);
        const dh = Math.abs(box.h - lastCenterBox.h);
        const moved = dw > 2 || dh > 2; // crude proxy for motion / zoom
        if (!moved) {
          if (now - lastStableTime > 800) {
            cameraFrame.classList.add("stable");
          }
        } else {
          cameraFrame.classList.remove("stable");
          lastStableTime = now;
        }
      } else {
        lastCenterBox = box;
        lastStableTime = now;
      }
      lastCenterBox = box;
      requestAnimationFrame(checkFrameStability);
    }

    function handleFiles(list) {
      if (!list || !list.length) return;
      file = list[0];

      thumb.innerHTML = "";
      if (file.type.startsWith("image/")) {
        const img = document.createElement("img");
        img.alt = file.name;
        img.src = URL.createObjectURL(file);
        thumb.appendChild(img);
      } else {
        const div = document.createElement("div");
        div.textContent = file.name;
        thumb.appendChild(div);
      }
      preview.hidden = false;
      btnReplace.hidden = false;

      runCloudOCR(file);
    }

    function parseLines(text) {
      return text
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(Boolean);
    }

    function pickVendor(fields, text) {
      const f = fields || {};
      const structuredVendor =
        f["supplier_name"] ||
        f["merchant_name"] ||
        f["vendor_name"];
      if (structuredVendor) return structuredVendor;

      const lines = parseLines(text);
      const skipWords = [
        "invoice", "invoice n", "receipt", "paid on",
        "payment method", "amount due", "total",
        "thanks for your business", "thank you for your business",
        "customer's address", "customer address", "designation",
        "unit price", "quantity", "balance due"
      ];
      for (const line of lines) {
        const low = line.toLowerCase();
        if (skipWords.some(w => low.includes(w))) continue;
        if (/^\d/.test(line)) continue;
        return line;
      }
      return "";
    }

    function pickDate(fields, text) {
      const f = fields || {};
      const structured = (f["receipt_date"] || f["invoice_date"] || "").trim();
      if (structured) {
        if (/^\d{4}-\d{2}-\d{2}/.test(structured)) return structured.slice(0, 10);
      }

      const lines = parseLines(text);
      const datePatterns = [
        /\b\d{4}-\d{2}-\d{2}\b/,
        /\b\d{1,2}\/\d{1,2}\/\d{2,4}\b/
      ];
      for (const line of lines) {
        for (const r of datePatterns) {
          const m = line.match(r);
          if (m) {
            const raw = m[0];
            if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return raw;
            const parts = raw.replace(/-/g, "/").split("/");
            if (parts.length === 3) {
              const [a, b, c] = parts;
              if (a.length === 4) {
                return [a, b.padStart(2, "0"), c.padStart(2, "0")].join("-");
              } else {
                const year = c.length === 2 ? "20" + c : c;
                return [year, a.padStart(2, "0"), b.padStart(2, "0")].join("-");
              }
            }
          }
        }
      }
      return "";
    }

    function pickTotals(fields, text) {
      const f = fields || {};
      let totalField = (f["total_amount"] || "").trim();
      let taxField   = (f["tax_amount"] || "").trim();
      let currency   = (f["currency"] || f["currency_code"] || "").toUpperCase();

      const lines = parseLines(text);
      const moneyRegex = /(\d+(?:[.,]\d{2})?)/;

      const moneyCandidates = [];
      for (let i = 0; i < lines.length; i++) {
        const l = lines[i];
        if (/[â‚¬$]|usd|eur|gbp/i.test(l)) {
          const m = l.match(moneyRegex);
          if (m) {
            const val = parseFloat(m[1].replace(",", "."));
            if (!isNaN(val)) {
              moneyCandidates.push({
                value: val,
                raw: m[1],
                line: l.toLowerCase(),
                idx: i
              });
            }
          }
        }
      }
      const maxCandidate = moneyCandidates.reduce(
        (max, c) => c.value > max ? c.value : max,
        0
      );

      let textTotal = null;
      for (let i = 0; i < lines.length; i++) {
        const l = lines[i].toLowerCase();
        if (
          l.includes("amount due") ||
          l.includes("balance due") ||
          l === "total" ||
          l.startsWith("total ")
        ) {
          const windowLines = [lines[i], lines[i + 1], lines[i + 2]];
          for (const wl of windowLines) {
            if (!wl) continue;
            if (!/[â‚¬$]|usd|eur|gbp/i.test(wl)) continue;
            const m = wl.match(moneyRegex);
            if (m) {
              const v = parseFloat(m[1].replace(",", "."));
              if (!isNaN(v)) {
                textTotal = { num: v, raw: m[1] };
                break;
              }
            }
          }
          if (textTotal) break;
        }
      }

      let chosenTotal = "";
      if (totalField) {
        const parsed = parseFloat(totalField.replace(",", "."));
        if (!isNaN(parsed) && parsed > 0) {
          if (!maxCandidate || parsed >= maxCandidate * 0.5) {
            chosenTotal = totalField;
          }
        }
      }
      if (!chosenTotal && textTotal) {
        chosenTotal = textTotal.raw;
      }

      let chosenTax = taxField;
      if (!chosenTax) {
        for (const line of lines) {
          if (!/tax|vat/i.test(line)) continue;
          if (!/[â‚¬$]|usd|eur|gbp/i.test(line)) continue;
          const m = line.match(moneyRegex);
          if (m) {
            chosenTax = m[1];
            break;
          }
        }
      }

      if (!currency) {
        for (const c of moneyCandidates) {
          if (/usd|\$/i.test(c.line)) { currency = "USD"; break; }
          if (/eur|â‚¬/.test(c.line))   { currency = "EUR"; break; }
          if (/gbp|Â£/i.test(c.line))  { currency = "GBP"; break; }
        }
      }

      return { total: chosenTotal, tax: chosenTax, currency };
    }

    function guessCategoryFromText(text) {
      if (/diesel|gas|fuel|pump/i.test(text)) return "Fuel";
      if (/hotel|motel|inn|lodging/i.test(text)) return "Lodging";
      if (/restaurant|cafe|food|meal/i.test(text)) return "Meals";
      if (/toll|fee/i.test(text)) return "Fees/Tolls";
      if (/parts|repair|service/i.test(text)) return "Repairs/Parts";
      if (/supply|supplies/i.test(text)) return "Supplies";
      return "";
    }

    function pickPaymentMethod(fields, text) {
      const f = fields || {};
      const val = (f["payment_type"] || "").toLowerCase();
      const source = (val || text.toLowerCase());
      if (/visa|mastercard|amex|american express|discover|card|credit|debit/i.test(source)) {
        return "card";
      }
      if (/cash|reimburse/i.test(source)) {
        return "reimb";
      }
      return "";
    }

    async function runCloudOCR(f) {
      ocrStatus.textContent = "Uploading to cloud OCRâ€¦";

      try {
        const base64 = await new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onerror = () => reject(reader.error);
          reader.onload = () => {
            const res = String(reader.result || "");
            const parts = res.split(",");
            resolve(parts.length > 1 ? parts[1] : "");
          };
          reader.readAsDataURL(f);
        });

        if (!base64) {
          ocrStatus.textContent = "Could not read file. Fill in manually.";
          return;
        }

        ocrStatus.textContent = "Processing receipt in cloudâ€¦";

        const resp = await fetch(OCR_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            mode: "receipt",
            content: base64,
            mimeType: f.type || "application/pdf"
          })
        });

        if (!resp.ok) {
          const txt = await resp.text();
          console.error("OCR HTTP error:", resp.status, txt);
          ocrStatus.textContent = "OCR error from server. You can fill in manually.";
          return;
        }

        const json = await resp.json();
        if (!json.ok) {
          console.error("OCR logical error:", json);
          ocrStatus.textContent = "OCR could not read that receipt. Fill in manually.";
          return;
        }

        const fields = json.fields || {};
        const docText = (json.document && json.document.text) || "";

        ocrStatus.textContent = "Auto-filling from receiptâ€¦";

        try {
          const vendor  = pickVendor(fields, docText);
          const date    = pickDate(fields, docText);
          const totals  = pickTotals(fields, docText);
          const cat     = guessCategoryFromText(docText);
          const pay     = pickPaymentMethod(fields, docText);

          if (!merchant.value && vendor) {
            merchant.value = vendor.slice(0, 64);
          }

          if (!rdate.value && date) {
            rdate.value = date;
          }

          if (!total.value && totals.total) {
            const num = parseFloat(String(totals.total).replace(",", "."));
            if (!isNaN(num) && num > 0) {
              total.value = usdFmt.format(num);
            }
          }

          if (!paymethod.value && pay) {
            paymethod.value = pay;
          }

          if (!category.value && cat) {
            for (let i = 0; i < category.options.length; i++) {
              if (category.options[i].text === cat) {
                category.selectedIndex = i;
                break;
              }
            }
          }

          ocrStatus.textContent = "Auto-filled from receipt. Review and save.";
        } catch (parseErr) {
          console.warn("Parse from OCR failed:", parseErr);
          ocrStatus.textContent = "Read text, but could not parse details. Fill in manually.";
        }
      } catch (e) {
        console.error("Cloud OCR failed:", e);
        ocrStatus.textContent = "OCR failed. You can fill in manually.";
      }
    }

    function showToast(msg = "Saved.") {
      const t = $("toast");
      t.textContent = msg;
      t.classList.remove("show");
      void t.offsetWidth;
      t.classList.add("show");
    }

    $("btnSave").addEventListener("click", async () => {
      const submittedByName  = getSubmittedByName();
      const submittedByEmail = getSubmittedByEmail();

      if (!submittedByName.trim()) {
        alert("Submitted By is required.");
        return;
      }
      if (!submitted.value) {
        alert("Submitted Date is required.");
        return;
      }
      if (!paymethod.value) {
        alert("Payment Method is required.");
        return;
      }
      if (!category.value) {
        alert("Category is required.");
        return;
      }
      if (!merchant.value.trim()) {
        alert("Merchant is required.");
        return;
      }
      if (!rdate.value) {
        alert("Receipt Date is required.");
        return;
      }
      const totalNum = parseUSD(total.value);
      if (totalNum === "") {
        alert("Total amount is required.");
        return;
      }

      const payload = {
        // keep legacy flat field
        who: submittedByName,
        // add structured Submitted By like the grain bag entry does
        submittedBy: {
          name: submittedByName,
          email: submittedByEmail || null
        },
        submitted: submitted.value || todayISO(),
        merchant: merchant.value.trim(),
        rdate: rdate.value,
        category: category.value,
        total: totalNum,
        paymethod: paymethod.value,
        project: project.value.trim(),
        notes: notes.value.trim(),
        status: "Submitted",
        t: Date.now()
      };

      try {
        if (window.firebase?.firestore) {
          const db = firebase.firestore();
          await db.collection("expenditures").add({
            ...payload,
            createdAt: (firebase.firestore.FieldValue &&
                        firebase.firestore.FieldValue.serverTimestamp)
                       ? firebase.firestore.FieldValue.serverTimestamp()
                       : null
          });
        }
        showToast("Saved.");
      } catch (e) {
        console.error(e);
        showToast("Saved locally.");
      }
    });

    $("btnClear").addEventListener("click", () => {
      ["merchant", "rdate", "category", "total", "paymethod", "project", "notes"].forEach(id => {
        const el = $(id);
        if (!el) return;
        if (el.tagName === "SELECT") el.selectedIndex = 0;
        else el.value = "";
      });
      preview.hidden = true;
      btnReplace.hidden = true;
      ocrStatus.textContent = "";
      thumb.innerHTML = "";
      // keep Submitted By + Submitted Date as-is (same pattern as bag form keeping default)
    });

    // Init employees combo after auth is ready
    initEmployeesCombo();
  })();
  </script>
</body>
</html>
